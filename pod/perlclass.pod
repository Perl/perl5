=head1 NAME

perlclass - Perl class syntax

=head1 DESCRIPTION

    use v5.36;
    use feature 'class';

    class My::Example 1.234 {
        field $x;
        ADJUST { $x = "Hello, world"; }

        method print_message { say $x; }
    }

    My::Example->new->print_message;

C<class> is like C<package>. Classes automatically get a C<new> method; you
don't have to (and should not) write one.

C<method> is like C<sub> but automatically gains a C<$self> lexical.

C<ADJUST> blocks run during construction and are the way to add code that runs
during the construction time of each instance. They also have a C<$self>
lexical.

C<field> is like C<my> but only visible within C<methods> and C<ADJUST>
blocks.

Instances get their own value storage for fields

    class My::Counter {
        field $count; ADJUST { $count = 0; }

        method incr { $count++ }
        method val  { return $count; }
    }

    my $ca = My::Counter->new;
    $ca->incr; $ca->incr; $ca->incr;

    my $cb = My::Counter->new;
    $cb->incr;

    say "Counter A is at ", $ca->val;
    say "Counter B is at ", $cb->val;

C<methods> always act as if C<use feature 'signatures'> is in effect. You do
not need to worry about the C<$self> lexical: it is automatically created and
populated with the object instance, which will not appear in the arguments
list as far as the signature is concerned.

    class Example::WithSignatures {
        method greet($name = "someone") {
            say "Hello, $name";
        }
    }

Classes may inherit from B<one> superclass, by using the C<:isa> class
attribute.

  class Example::Base { ... }

  class Example::Subclass :isa(Example::Base) { ... }

Inherited methods are visible and may be invoked. Fields are always lexical
and therefore not visible by inheritence.

The C<:isa> attribute may request a minimum version of the base class; it is
applied similar to C<use>; if the provided version is too low it will fail at
compile time.

  class Example::Subclass :isa(Example::Base 2.345) { ... }

The C<:isa> attribute will attempt to C<require> the named module if it is not
already loaded.

=cut
