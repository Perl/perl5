#!/bin/sh

# this script is used to regenerate a number of special build files
# based on either information contained in a file called .patch or
# directly from git.
# The files involved are:
#   .patchnum         # information about the current checkout
#   lib/Config_git.pl # holds some special configure settings related to git
#   unpushed.h        # header file used by patchlevel.h to store unpushed commits

existing_patchnum=$(cat .patchnum 2>/dev/null)
existing_config=$(cat lib/Config_git.pl 2>/dev/null)
existing_unpushed=$(cat unpushed.h 2>/dev/null)

unpushed_commits='/*no-op*/'
if [ -s ".patch" ] ; then
	# this is the minimal expectation for the 
	read branch snapshot_created commit_id describe < .patch
	changed=""
	extra_info="git_snapshot_date='$snapshot_created'"
	commit_title='Snapshot of:'
elif [ -d ".git" ]; then
	branch=$(git branch | awk 'BEGIN{ORS=""} /\*/ { print $2 }')
	test -n "$branch" && remote=$(git config branch.$branch.remote)
	commit_id=$(git rev-parse HEAD)
	changed=$(git diff-index --name-only HEAD)
	describe=$(git describe --tags)
	commit_created=$(git log -1 --pretty='format:%ci')
	extra_info="git_commit_date='$commit_created'"
	if [ -n "$branch" ] && [ -n "$remote" ]; then
		unpushed_commit_list=$(git cherry $remote/$branch | awk 'BEGIN{ORS=","} /+/ {print $2}' | sed -e 's/,$//')
		unpushed_commits=$(git cherry $remote/$branch | awk 'BEGIN{ORS="\t\\\n"} /+/ {print ",\"" $2 "\""}')

		if [ -n "$unpushed_commits" ]; then
			commit_title="Local Commit:"
			ancestor=`git rev-parse $remote/$branch`
			extra_info="$extra_info
git_ancestor='$ancestor'
git_unpushed='$unpushed_commit_list'"
		fi
			
	fi
else
	cat <<SNDOGS
Something is wrong with your source tree. You should 
either have a .git directory and a functional git toolset
OR should have a .patch file in the source tree. Please
report the particulars of this situation to 
perl5-porters@perl.org.
SNDOGS
	exit 2
fi

# Set up defaults for various values
new_patchnum="describe: $describe"
if [ -n "$changed" ]; then
	changed="true"
	commit_title="Derived from:"
	new_patchnum="$new_patchnum
status: uncommitted-changes"
fi
test -z "$commit_title" && commit_title='Commit id:'

new_unpushed=$(cat <<EOFTEXT
/*********************************************************************
* WARNING: unpushed.h is automatically generated by make_patchnum.sh *
*          DO NOT EDIT DIRECTLY - edit make_patchnum.sh instead      *
*********************************************************************/
#define PERL_GIT_UNPUSHED_COMMITS       $unpushed_commits
/*leave-this-comment*/
EOFTEXT
)
new_config=$(cat <<EOFDATA
#################################################################
# WARNING: lib/Config_git.pl is generated by make_patchnum.sh   #
#          DO NOT EDIT DIRECTLY - edit make_patchnum.sh instead #
#################################################################
\$Config::Git_Data=<<'ENDOFGIT';
git_commit_id='$commit_id'
git_describe='$describe'
git_branch='$branch'
git_uncommitted_changes='$changed'
git_commit_id_title='$commit_title'
$extra_info
ENDOFGIT
EOFDATA
)
# only update the files if necessary, other build product depends on these files
if [ "$existing_patchnum" != "$new_patchnum" ] || [ "$new_config" != "$existing_config" ] || [ "$existing_unpushed" != "$new_unpushed" ]; then
	echo "Updating .patchnum and lib/Config_git.pl"
	echo "$new_patchnum" > .patchnum
	echo "$new_config" > lib/Config_git.pl
	echo "$new_unpushed" > unpushed.h
else
	echo "Reusing .patchnum and lib/Config_git.pl"
fi

