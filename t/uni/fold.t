use strict;
use warnings;

# re/fold_grind.t has more complex tests, but doesn't test every fold
# This file also tests the fc() keyword.

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
    skip_all_without_unicode_tables();
    skip_all_if_miniperl("miniperl, no Unicode::Normalize");
    require Config; import Config;
    require './charset_tools.pl';
    require './loc_tools.pl';   # Contains find_utf8_ctype_locale()
}

use feature 'unicode_strings';
use Unicode::UCD qw(all_casefolds);

binmode *STDOUT, ":utf8";

our $TODO;


plan("no_plan");
# Read in the official case folding definitions.
my $casefolds = all_casefolds();
my @folds;
my @CF;
my @simple_folds;
my %reverse_fold;
use Unicode::UCD;
use charnames();

foreach my $decimal_code_point (sort { $a <=> $b } keys %$casefolds) {
    # We only use simple folds in fc(), since the regex engine uses full case
    # folding.

    my $name = charnames::viacode($decimal_code_point);
    my $type = $casefolds->{$decimal_code_point}{'status'};
    my $code = $casefolds->{$decimal_code_point}{'code'};
    my $simple = $casefolds->{$decimal_code_point}{'simple'};
    my $full = $casefolds->{$decimal_code_point}{'full'};

    if ($simple && $simple ne $full) { # If there is a distinction
        push @simple_folds, [ $code, $simple, $type, $name ];
    }

    push @CF, [ $code, $full, $type, $name ];

    # Get the inverse fold for single-char mappings.
    $reverse_fold{pack "W*", hex $simple} = pack "W*", $decimal_code_point if $simple;
}

foreach my $test_ref ( @simple_folds ) {
    use feature 'fc';
    my ($code, $mapping, $type, $name) = @$test_ref;
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);

    my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
    {
        isnt(fc($c), $f, "$code - $name - $mapping - $type - Full casefolding, fc(\\x{$code}) ne $against");
        isnt("\F$c", $f, "$code - $name - $mapping - $type - Full casefolding, qq{\\F\\x{$code}} ne $against");
    }
}

foreach my $test_ref (@CF) {
    my ($code, $mapping, $type, $name) = @$test_ref;
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);
    my $f_length = length $f;
    foreach my $test (
            qq[":$c:" =~ /:$c:/],
            qq[":$c:" =~ /:$c:/i],
            qq[":$c:" =~ /:[_$c]:/], # Place two chars in [] so doesn't get
                                     # optimized to a non-charclass
            qq[":$c:" =~ /:[_$c]:/i],
            qq[":$c:" =~ /:$f:/i],
            qq[":$f:" =~ /:$c:/i],
    ) {
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }

    {
        # fc() tests
        my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
        is(CORE::fc($c), $f,
            "$code - $name - $mapping - $type - fc(\\x{$code}) eq $against");
        is("\F$c", $f, "$code - $name - $mapping - $type - qq{\\F\\x{$code}} eq $against");

        # And here we test bytes. For [A-Za-z0-9], the fold is the same as lc under
        # bytes. For everything else, it's the bytes that formed the original string.
        if ( $c =~ /[A-Za-z0-9]/ ) {
            use bytes;
            is(CORE::fc($c), lc($c), "$code - $name - fc and use bytes, ascii");
        } else {
            my $copy = "" . $c;
            utf8::encode($copy);
            is($copy, do { use bytes; CORE::fc($c) }, "$code - $name - fc and use bytes");
        }
    }
    # Certain tests weren't convenient to put in the list above since they are
    # TODO's in multi-character folds.
    if ($f_length == 1) {

        # The qq loses the utf8ness of ":$f:".  These tests are not about
        # finding bugs in utf8ness, so make sure it's utf8.
        my $test = qq[my \$s = ":$f:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
        $test = qq[":$c:" =~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
    else {

        # There are two classes of multi-char folds that need more work.  For
        # example,
        #   ":√ü:" =~ /:[_s]{2}:/i
        #   ":ss:" =~ /:[_√ü]:/i
        #
        # Some of the old tests for the second case happened to pass somewhat
        # coincidentally.  But none would pass if changed to this.
        #   ":SS:" =~ /:[_√ü]:/i
        #
        # As the capital SS doesn't get folded.  When those pass, it means
        # that the code has been changed to take into account folding in the
        # string, and all should pass, capitalized or not (this wouldn't be
        # true for [^complemented character classes], for which the fold case
        # is better, but these aren't used in this .t currently.  So, what is
        # done is to essentially upper-case the string for this class (but use
        # the reverse fold not uc(), as that is more correct)
        my $u;
        for my $i (0 .. $f_length - 1) {
            my $cur_char = substr($f, $i, 1);
            $u .= $reverse_fold{$cur_char} || $cur_char;
        }
        my $test;

        # A multi-char fold should not match just one char;
        # e.g., ":√ü:" !~ /:[_s]:/i
        $test = qq[":$c:" !~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";

        TODO: { # e.g., ":√ü:" =~ /:[_s]{2}:/i
            local $TODO = 'Multi-char fold in [character class]';

            $test = qq[":$c:" =~ /:[_$f]{$f_length}:/i];
            ok eval $test, "$code - $name - $mapping - $type - $test";
        }

        # e.g., ":SS:" =~ /:[_√ü]:/i now pass, so TODO has been removed, but
        # since they use '$u', they are left out of the main loop
        $test = qq[ my \$s = ":$u:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";

        my $bracketed_f = ($f =~ s/(.)/[$1]/gr);
        $test = qq[":$c:" =~ /:$bracketed_f:/iu];
        ok eval $test, "$code - $name - $mapping - $type - $test";

        my @f_chars = ($f =~ / (.) (.) (.?) /x);
        my $every_other_bracketed_f = "[$f_chars[0]]$f_chars[1]";
        $every_other_bracketed_f .= "[$f_chars[2]]" if $f_chars[2];
        $test = qq[":$c:" =~ /:$every_other_bracketed_f:/iu];
        ok eval $test, "$code - $name - $mapping - $type - $test";

        my $other_every_bracketed_f = "$f_chars[0]";
        $other_every_bracketed_f .= "[$f_chars[1]]";
        $other_every_bracketed_f .= "$f_chars[2]" if $f_chars[2];
        $test = qq[":$c:" =~ /:$other_every_bracketed_f:/iu];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
}

{
    use utf8;
    use feature qw(fc);
    # These three come from the ICU project's test suite, more especifically
    # http://icu.sourcearchive.com/documentation/4.4~rc1-1/strcase_8cpp-source.html

    my $s = "A\N{U+00df}\N{U+00b5}\N{U+fb03}\N{U+1040C}\N{U+0130}\N{U+0131}";
    #\N{LATIN CAPITAL LETTER A}\N{LATIN SMALL LETTER SHARP S}\N{MICRO SIGN}\N{LATIN SMALL LIGATURE FFI}\N{DESERET CAPITAL LETTER AY}\N{LATIN CAPITAL LETTER I WITH DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    my $f = "ass\N{U+03bc}ffi\N{U+10434}i\N{U+0307}\N{U+0131}";
    #\N{LATIN SMALL LETTER A}\N{LATIN SMALL LETTER S}\N{LATIN SMALL LETTER S}\N{GREEK SMALL LETTER MU}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER I}\N{DESERET SMALL LETTER AY}\N{LATIN SMALL LETTER I}\N{COMBINING DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    is(fc($s), $f, "ICU's casefold test passes");
    is("\F$s", $f, "ICU's casefold test passes");

    is( fc("aBƒ∞Iƒ±œê√üÔ¨ÉÒüøø"), "abiÃáiƒ±Œ≤ssffiÒüøø" );
    is( "\FaBƒ∞Iƒ±œê√üÔ¨ÉÒüøø", "abiÃáiƒ±Œ≤ssffiÒüøø" );
#    TODO: {
#        local $::TODO = "turkic special cases";
#        is( fc "aBƒ∞Iƒ±œê√üÔ¨ÉÒüøø", "abiƒ±ƒ±Œ≤ssffiÒüøø" );
#    }

    # The next batch come from http://www.devdaily.com/java/jwarehouse/lucene/contrib/icu/src/test/org/apache/lucene/analysis/icu/TestICUFoldingFilter.java.shtml
    # Except the article got most casings wrong. Or maybe Lucene does.

    is( fc("This is a test"), "this is a test" );
    is( fc("Ru√ü"), "russ"    );
    is( fc("ŒúŒÜŒ™ŒüŒ£"), "ŒºŒ¨œäŒøœÉ" );
    is( fc("ŒúŒ¨œäŒøœÇ"), "ŒºŒ¨œäŒøœÉ" );
    is( fc("êêñ"), "êêæ"       );
    is( fc("r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9")),
           "r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9") );
    is( fc("re\x{0301}sume\x{0301}"), "re\x{301}sume\x{301}" );
    is( fc("ELƒ∞F"), "eli\x{307}f" );
    is( fc("eli\x{307}f"), "eli\x{307}f");

    # This batch comes from
    # http://www.java2s.com/Open-Source/Java-Document/Internationalization-Localization/icu4j/com/ibm/icu/dev/test/lang/UCharacterCaseTest.java.htm
    # Which uses ICU as the backend.

    my @folding_mixed = (
        uni_to_native("\x{61}\x{42}\x{130}\x{49}\x{131}\x{3d0}\x{df}\x{fb03}"),
        "A" . uni_to_native("\x{df}\x{b5}\x{fb03}\x{1040C}\x{130}\x{131}"),
    );

    my @folding_default = (
        uni_to_native("\x{61}\x{62}\x{69}\x{307}\x{69}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
        "ass\x{3bc}ffi\x{10434}i\x{307}\x{131}"
    );

    my @folding_exclude_turkic = (
        uni_to_native("\x{61}\x{62}\x{69}\x{131}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
                         "ass\x{3bc}ffi\x{10434}i\x{131}",
    );

    is( fc($folding_mixed[1]), $folding_default[1] );

    is( fc($folding_mixed[0]), $folding_default[0] );

}

{
    use utf8;
    # Table stolen from tchrist's mail in
    # http://bugs.python.org/file23051/casing-tests.py
    # and http://98.245.80.27/tcpc/OSCON2011/case-test.python3
    # For reference, it's a longer version of what he posted here:
    # http://stackoverflow.com/questions/6991038/case-insensitive-storage-and-unicode-compatibility

    #Couple of repeats because I'm lazy, not tchrist's fault.

    #This should probably go in t/op/lc.t

    my @test_table = (
# ORIG LC_SIMPLE TC_SIMPLE UC_SIMPLE LC_FULL TC_FULL UC_FULL FC_SIMPLE FC_TURKIC FC_FULL
[ '√æ«Ωr rihtes', '√æ«Ωr rihtes', '√û«Ωr Rihtes', '√û«ºR RIHTES', '√æ«Ωr rihtes', '√û«Ωr Rihtes', '√û«ºR RIHTES', '√æ«Ωr rihtes', '√æ«Ωr rihtes', '√æ«Ωr rihtes',  ],
[ 'du»ùe√∞lice', 'du»ùe√∞lice', 'Du»ùe√∞lice', 'DU»úE√êLICE', 'du»ùe√∞lice', 'Du»ùe√∞lice', 'DU»úE√êLICE', 'du»ùe√∞lice', 'du»ùe√∞lice', 'du»ùe√∞lice',  ],
[ '√Üvar Arnfj√∂r√∞ Bjarmason', '√¶var arnfj√∂r√∞ bjarmason', '√Üvar Arnfj√∂r√∞ Bjarmason', '√ÜVAR ARNFJ√ñR√ê BJARMASON', '√¶var arnfj√∂r√∞ bjarmason', '√Üvar Arnfj√∂r√∞ Bjarmason', '√ÜVAR ARNFJ√ñR√ê BJARMASON', '√¶var arnfj√∂r√∞ bjarmason', '√¶var arnfj√∂r√∞ bjarmason', '√¶var arnfj√∂r√∞ bjarmason',  ],
[ '–ö–∏—Ä–∏–ª–ª–∏—Ü–∞', '–∫–∏—Ä–∏–ª–ª–∏—Ü–∞', '–ö–∏—Ä–∏–ª–ª–∏—Ü–∞', '–ö–ò–†–ò–õ–õ–ò–¶–ê', '–∫–∏—Ä–∏–ª–ª–∏—Ü–∞', '–ö–∏—Ä–∏–ª–ª–∏—Ü–∞', '–ö–ò–†–ò–õ–õ–ò–¶–ê', '–∫–∏—Ä–∏–ª–ª–∏—Ü–∞', '–∫–∏—Ä–∏–ª–ª–∏—Ü–∞', '–∫–∏—Ä–∏–ª–ª–∏—Ü–∞',  ],
[ 'ƒ≥', 'ƒ≥', 'ƒ≤', 'ƒ≤', 'ƒ≥', 'ƒ≤', 'ƒ≤', 'ƒ≥', 'ƒ≥', 'ƒ≥',  ],
[ 'Van Dƒ≥ke', 'van dƒ≥ke', 'Van Dƒ≥ke', 'VAN Dƒ≤KE', 'van dƒ≥ke', 'Van Dƒ≥ke', 'VAN Dƒ≤KE', 'van dƒ≥ke', 'van dƒ≥ke', 'van dƒ≥ke',  ],
[ 'VAN Dƒ≤KE', 'van dƒ≥ke', 'Van Dƒ≥ke', 'VAN Dƒ≤KE', 'van dƒ≥ke', 'Van Dƒ≥ke', 'VAN Dƒ≤KE', 'van dƒ≥ke', 'van dƒ≥ke', 'van dƒ≥ke',  ],
[ 'eÔ¨Écient', 'eÔ¨Écient', 'EÔ¨Écient', 'EÔ¨ÉCIENT', 'eÔ¨Écient', 'EÔ¨Écient', 'EFFICIENT', 'eÔ¨Écient', 'efficient', 'efficient',  ],
[ 'Ô¨Çour', 'Ô¨Çour', 'Ô¨Çour', 'Ô¨ÇOUR', 'Ô¨Çour', 'Flour', 'FLOUR', 'Ô¨Çour', 'flour', 'flour',  ],
[ 'Ô¨Çour and water', 'Ô¨Çour and water', 'Ô¨Çour And Water', 'Ô¨ÇOUR AND WATER', 'Ô¨Çour and water', 'Flour And Water', 'FLOUR AND WATER', 'Ô¨Çour and water', 'flour and water', 'flour and water',  ],
[ '«≥ur', '«≥ur', '«≤ur', '«±UR', '«≥ur', '«≤ur', '«±UR', '«≥ur', '«≥ur', '«≥ur',  ],
[ '«≤ur', '«≥ur', '«≤ur', '«±UR', '«≥ur', '«≤ur', '«±UR', '«≥ur', '«≥ur', '«≥ur',  ],
[ '«±UR', '«≥ur', '«≤ur', '«±UR', '«≥ur', '«≤ur', '«±UR', '«≥ur', '«≥ur', '«≥ur',  ],
[ '«≥ur mountain', '«≥ur mountain', '«≤ur Mountain', '«±UR MOUNTAIN', '«≥ur mountain', '«≤ur Mountain', '«±UR MOUNTAIN', '«≥ur mountain', '«≥ur mountain', '«≥ur mountain',  ],
[ '«≤ur Mountain', '«≥ur mountain', '«≤ur Mountain', '«±UR MOUNTAIN', '«≥ur mountain', '«≤ur Mountain', '«±UR MOUNTAIN', '«≥ur mountain', '«≥ur mountain', '«≥ur mountain',  ],
[ '«±UR MOUNTAIN', '«≥ur mountain', '«≤ur Mountain', '«±UR MOUNTAIN', '«≥ur mountain', '«≤ur Mountain', '«±UR MOUNTAIN', '«≥ur mountain', '«≥ur mountaƒ±n', '«≥ur mountain',  ],
[ 'po≈øt', 'po≈øt', 'Po≈øt', 'POST', 'po≈øt', 'Po≈øt', 'POST', 'post', 'post', 'post',  ],
[ 'poÔ¨Ö', 'poÔ¨Ö', 'PoÔ¨Ö', 'POÔ¨Ö', 'poÔ¨Ö', 'PoÔ¨Ö', 'POST', 'poÔ¨Ö', 'post', 'post',  ],
[ 'Ô¨Öop', 'Ô¨Öop', 'Ô¨Öop', 'Ô¨ÖOP', 'Ô¨Öop', 'Stop', 'STOP', 'Ô¨Öop', 'stop', 'stop',  ],
[ 'tsch√º√ü', 'tsch√º√ü', 'Tsch√º√ü', 'TSCH√ú√ü', 'tsch√º√ü', 'Tsch√º√ü', 'TSCH√úSS', 'tsch√º√ü', 'tsch√ºss', 'tsch√ºss',  ],
[ 'TSCH√ú·∫û', 'tsch√º√ü', 'Tsch√º√ü', 'TSCH√ú·∫û', 'tsch√º√ü', 'Tsch√º√ü', 'TSCH√ú·∫û', 'tsch√º√ü', 'tsch√ºss', 'tsch√ºss',  ],
[ 'wei√ü', 'wei√ü', 'Wei√ü', 'WEI√ü', 'wei√ü', 'Wei√ü', 'WEISS', 'wei√ü', 'weiss', 'weiss',  ],
[ 'WEI·∫û', 'wei√ü', 'Wei√ü', 'WEI·∫û', 'wei√ü', 'Wei√ü', 'WEI·∫û', 'wei√ü', 'weƒ±ss', 'weiss',  ],
[ '·∫ûIEW', '√üiew', '·∫ûiew', '·∫ûIEW', '√üiew', '·∫ûiew', '·∫ûIEW', '√üiew', 'ssƒ±ew', 'ssiew',  ],
[ 'Œ±ÃÄÕÖ', 'Œ±ÃÄÕÖ', 'ŒëÃÄÕÖ', 'ŒëÃÄŒô', 'Œ±ÃÄÕÖ', 'ŒëÃÄÕÖ', 'ŒëÃÄŒô', 'Œ±ÃÄŒπ', 'Œ±ÃÄŒπ', 'Œ±ÃÄŒπ',  ],
[ '·æ∫Œπ', '·Ω∞Œπ', '·æ∫Œπ', '·æ∫Œô', '·Ω∞Œπ', '·æ∫Œπ', '·æ∫Œô', '·Ω∞Œπ', '·Ω∞Œπ', '·Ω∞Œπ',  ],
[ '·æ∫Œô', '·Ω∞Œπ', '·æ∫Œπ', '·æ∫Œô', '·Ω∞Œπ', '·æ∫Œπ', '·æ∫Œô', '·Ω∞Œπ', '·Ω∞Œπ', '·Ω∞Œπ',  ],
[ '·æ≤', '·æ≤', '·æ≤', '·æ≤', '·æ≤', '·æ∫ÕÖ', '·æ∫Œô', '·æ≤', '·Ω∞Œπ', '·Ω∞Œπ',  ],
[ '·æ∫ÕÖ', '·Ω∞ÕÖ', '·æ∫ÕÖ', '·æ∫Œô', '·Ω∞ÕÖ', '·æ∫ÕÖ', '·æ∫Œô', '·Ω∞Œπ', '·Ω∞Œπ', '·Ω∞Œπ',  ],
[ '·æ∫Œô', '·Ω∞Œπ', '·æ∫Œπ', '·æ∫Œô', '·Ω∞Œπ', '·æ∫Œπ', '·æ∫Œô', '·Ω∞Œπ', '·Ω∞Œπ', '·Ω∞Œπ',  ],
[ '·æ≤ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø', '·æ≤ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø', '·æ≤ Œ£œÑŒø ŒîŒπŒ¨ŒøŒªŒø', '·æ≤ Œ£Œ§Œü ŒîŒôŒÜŒüŒõŒü', '·æ≤ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø', '·æ∫ÕÖ Œ£œÑŒø ŒîŒπŒ¨ŒøŒªŒø', '·æ∫Œô Œ£Œ§Œü ŒîŒôŒÜŒüŒõŒü', '·æ≤ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø', '·Ω∞Œπ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø', '·Ω∞Œπ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø',  ],
[ 'Œ±ÃÄÕÖ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø', 'Œ±ÃÄÕÖ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø', 'ŒëÃÄÕÖ Œ£œÑŒø ŒîŒπŒ±ÃÅŒøŒªŒø', 'ŒëÃÄŒô Œ£Œ§Œü ŒîŒôŒëÃÅŒüŒõŒü', 'Œ±ÃÄÕÖ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø', 'ŒëÃÄÕÖ Œ£œÑŒø ŒîŒπŒ±ÃÅŒøŒªŒø', 'ŒëÃÄŒô Œ£Œ§Œü ŒîŒôŒëÃÅŒüŒõŒü', 'Œ±ÃÄŒπ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø', 'Œ±ÃÄŒπ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø', 'Œ±ÃÄŒπ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø',  ],
[ 'êêºêêØêëÖêê®êëâêêØêêª', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêîêêØêëÖêê®êëâêêØêêª', 'êêîêêáêêùêêÄêê°êêáêêì', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêîêêØêëÖêê®êëâêêØêêª', 'êêîêêáêêùêêÄêê°êêáêêì', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêºêêØêëÖêê®êëâêêØêêª',  ],
[ 'êêîêêØêëÖêê®êëâêêØêêª', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêîêêØêëÖêê®êëâêêØêêª', 'êêîêêáêêùêêÄêê°êêáêêì', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêîêêØêëÖêê®êëâêêØêêª', 'êêîêêáêêùêêÄêê°êêáêêì', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêºêêØêëÖêê®êëâêêØêêª',  ],
[ 'êêîêêáêêùêêÄêê°êêáêêì', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêîêêØêëÖêê®êëâêêØêêª', 'êêîêêáêêùêêÄêê°êêáêêì', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêîêêØêëÖêê®êëâêêØêêª', 'êêîêêáêêùêêÄêê°êêáêêì', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêºêêØêëÖêê®êëâêêØêêª', 'êêºêêØêëÖêê®êëâêêØêêª',  ],
[ 'henry ‚Ö∑', 'henry ‚Ö∑', 'Henry ‚Öß', 'HENRY ‚Öß', 'henry ‚Ö∑', 'Henry ‚Öß', 'HENRY ‚Öß', 'henry ‚Ö∑', 'henry ‚Ö∑', 'henry ‚Ö∑',  ],
[ 'Henry ‚Öß', 'henry ‚Ö∑', 'Henry ‚Öß', 'HENRY ‚Öß', 'henry ‚Ö∑', 'Henry ‚Öß', 'HENRY ‚Öß', 'henry ‚Ö∑', 'henry ‚Ö∑', 'henry ‚Ö∑',  ],
[ 'HENRY ‚Öß', 'henry ‚Ö∑', 'Henry ‚Öß', 'HENRY ‚Öß', 'henry ‚Ö∑', 'Henry ‚Öß', 'HENRY ‚Öß', 'henry ‚Ö∑', 'henry ‚Ö∑', 'henry ‚Ö∑',  ],
[ 'i work at ‚ìö', 'i work at ‚ìö', 'I Work At ‚ìÄ', 'I WORK AT ‚ìÄ', 'i work at ‚ìö', 'I Work At ‚ìÄ', 'I WORK AT ‚ìÄ', 'i work at ‚ìö', 'i work at ‚ìö', 'i work at ‚ìö',  ],
[ 'I Work At ‚ìÄ', 'i work at ‚ìö', 'I Work At ‚ìÄ', 'I WORK AT ‚ìÄ', 'i work at ‚ìö', 'I Work At ‚ìÄ', 'I WORK AT ‚ìÄ', 'i work at ‚ìö', 'ƒ± work at ‚ìö', 'i work at ‚ìö',  ],
[ 'I WORK AT ‚ìÄ', 'i work at ‚ìö', 'I Work At ‚ìÄ', 'I WORK AT ‚ìÄ', 'i work at ‚ìö', 'I Work At ‚ìÄ', 'I WORK AT ‚ìÄ', 'i work at ‚ìö', 'ƒ± work at ‚ìö', 'i work at ‚ìö',  ],
[ 'istambul', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'istambul', 'istambul',  ],
[ 'iÃástanbul', 'iÃástanbul', 'IÃástanbul', 'IÃáSTANBUL', 'iÃástanbul', 'IÃástanbul', 'IÃáSTANBUL', 'iÃástanbul', 'iÃástanbul', 'iÃástanbul',  ],
[ 'IÃástanbul', 'iÃástanbul', 'IÃástanbul', 'IÃáSTANBUL', 'iÃástanbul', 'IÃástanbul', 'IÃáSTANBUL', 'iÃástanbul', 'ƒ±Ãástanbul', 'iÃástanbul',  ],
[ 'ƒ∞STANBUL', 'istanbul', 'ƒ∞stanbul', 'ƒ∞STANBUL', 'iÃástanbul', 'ƒ∞stanbul', 'ƒ∞STANBUL', 'ƒ∞stanbul', 'istanbul', 'iÃástanbul',  ],
[ 'œÉœÑŒπŒ≥ŒºŒ±œÇ', 'œÉœÑŒπŒ≥ŒºŒ±œÇ', 'Œ£œÑŒπŒ≥ŒºŒ±œÇ', 'Œ£Œ§ŒôŒìŒúŒëŒ£', 'œÉœÑŒπŒ≥ŒºŒ±œÇ', 'Œ£œÑŒπŒ≥ŒºŒ±œÇ', 'Œ£Œ§ŒôŒìŒúŒëŒ£', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'œÉœÑŒπŒ≥ŒºŒ±œÉ',  ],
[ 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'Œ£œÑŒπŒ≥ŒºŒ±œÉ', 'Œ£Œ§ŒôŒìŒúŒëŒ£', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'Œ£œÑŒπŒ≥ŒºŒ±œÉ', 'Œ£Œ§ŒôŒìŒúŒëŒ£', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'œÉœÑŒπŒ≥ŒºŒ±œÉ',  ],
[ 'Œ£Œ§ŒôŒìŒúŒëŒ£', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'Œ£œÑŒπŒ≥ŒºŒ±œÉ', 'Œ£Œ§ŒôŒìŒúŒëŒ£', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'Œ£œÑŒπŒ≥ŒºŒ±œÉ', 'Œ£Œ§ŒôŒìŒúŒëŒ£', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'œÉœÑŒπŒ≥ŒºŒ±œÉ', 'œÉœÑŒπŒ≥ŒºŒ±œÉ',  ],
[ ' Ä·¥Ä Ä·¥á', ' Ä·¥Ä Ä·¥á', '∆¶·¥Ä Ä·¥á', '∆¶·¥Ä∆¶·¥á', ' Ä·¥Ä Ä·¥á', '∆¶·¥Ä Ä·¥á', '∆¶·¥Ä∆¶·¥á', ' Ä·¥Ä Ä·¥á', ' Ä·¥Ä Ä·¥á', ' Ä·¥Ä Ä·¥á',  ],
[ '∆¶·¥Ä Ä·¥á', ' Ä·¥Ä Ä·¥á', '∆¶·¥Ä Ä·¥á', '∆¶·¥Ä∆¶·¥á', ' Ä·¥Ä Ä·¥á', '∆¶·¥Ä Ä·¥á', '∆¶·¥Ä∆¶·¥á', ' Ä·¥Ä Ä·¥á', ' Ä·¥Ä Ä·¥á', ' Ä·¥Ä Ä·¥á',  ],
[ '∆¶·¥Ä∆¶·¥á', ' Ä·¥Ä Ä·¥á', '∆¶·¥Ä Ä·¥á', '∆¶·¥Ä∆¶·¥á', ' Ä·¥Ä Ä·¥á', '∆¶·¥Ä Ä·¥á', '∆¶·¥Ä∆¶·¥á', ' Ä·¥Ä Ä·¥á', ' Ä·¥Ä Ä·¥á', ' Ä·¥Ä Ä·¥á',  ],
[ '‘¶‘ß', '‘ß‘ß', '‘¶‘ß', '‘¶‘¶', '‘ß‘ß', '‘¶‘ß', '‘¶‘¶', '‘ß‘ß', '‘ß‘ß', '‘ß‘ß',  ],
[ '‘ß‘ß', '‘ß‘ß', '‘¶‘ß', '‘¶‘¶', '‘ß‘ß', '‘¶‘ß', '‘¶‘¶', '‘ß‘ß', '‘ß‘ß', '‘ß‘ß',  ],
[ '‘¶‘ß', '‘ß‘ß', '‘¶‘ß', '‘¶‘¶', '‘ß‘ß', '‘¶‘ß', '‘¶‘¶', '‘ß‘ß', '‘ß‘ß', '‘ß‘ß',  ],
[ '‘¶‘¶', '‘ß‘ß', '‘¶‘ß', '‘¶‘¶', '‘ß‘ß', '‘¶‘ß', '‘¶‘¶', '‘ß‘ß', '‘ß‘ß', '‘ß‘ß',  ],
[ "√æ«Ωr rihtes", "√æ«Ωr rihtes", "√û«Ωr Rihtes", "√û«ºR RIHTES", "√æ«Ωr rihtes", "√û«Ωr Rihtes", "√û«ºR RIHTES", "√æ«Ωr rihtes", "√æ«Ωr rihtes", "√æ«Ωr rihtes",  ],
[ "du»ùe√∞lice", "du»ùe√∞lice", "Du»ùe√∞lice", "DU»úE√êLICE", "du»ùe√∞lice", "Du»ùe√∞lice", "DU»úE√êLICE", "du»ùe√∞lice", "du»ùe√∞lice", "du»ùe√∞lice",  ],
[ "Van Dƒ≥ke", "van dƒ≥ke", "Van Dƒ≥ke", "VAN Dƒ≤KE", "van dƒ≥ke", "Van Dƒ≥ke", "VAN Dƒ≤KE", "van dƒ≥ke", "van dƒ≥ke", "van dƒ≥ke",  ],
[ "Ô¨Å", "Ô¨Å", "Ô¨Å", "Ô¨Å", "Ô¨Å", "Fi", "FI", "Ô¨Å", "fi", "fi",  ],
[ "Ô¨Ålesystem", "Ô¨Ålesystem", "Ô¨Ålesystem", "Ô¨ÅLESYSTEM", "Ô¨Ålesystem", "Filesystem", "FILESYSTEM", "Ô¨Ålesystem", "filesystem", "filesystem",  ],
[ "eÔ¨Écient", "eÔ¨Écient", "EÔ¨Écient", "EÔ¨ÉCIENT", "eÔ¨Écient", "EÔ¨Écient", "EFFICIENT", "eÔ¨Écient", "efficient", "efficient",  ],
[ "Ô¨Çour and water", "Ô¨Çour and water", "Ô¨Çour And Water", "Ô¨ÇOUR AND WATER", "Ô¨Çour and water", "Flour And Water", "FLOUR AND WATER", "Ô¨Çour and water", "flour and water", "flour and water",  ],
[ "«≥", "«≥", "«≤", "«±", "«≥", "«≤", "«±", "«≥", "«≥", "«≥",  ],
[ "«≥ur mountain", "«≥ur mountain", "«≤ur Mountain", "«±UR MOUNTAIN", "«≥ur mountain", "«≤ur Mountain", "«±UR MOUNTAIN", "«≥ur mountain", "«≥ur mountain", "«≥ur mountain",  ],
[ "po≈øt", "po≈øt", "Po≈øt", "POST", "po≈øt", "Po≈øt", "POST", "post", "post", "post",  ],
[ "poÔ¨Ö", "poÔ¨Ö", "PoÔ¨Ö", "POÔ¨Ö", "poÔ¨Ö", "PoÔ¨Ö", "POST", "poÔ¨Ö", "post", "post",  ],
[ "Ô¨Öop", "Ô¨Öop", "Ô¨Öop", "Ô¨ÖOP", "Ô¨Öop", "Stop", "STOP", "Ô¨Öop", "stop", "stop",  ],
[ "tsch√º√ü", "tsch√º√ü", "Tsch√º√ü", "TSCH√ú√ü", "tsch√º√ü", "Tsch√º√ü", "TSCH√úSS", "tsch√º√ü", "tsch√ºss", "tsch√ºss",  ],
[ "TSCH√ú·∫û", "tsch√º√ü", "Tsch√º√ü", "TSCH√ú·∫û", "tsch√º√ü", "Tsch√º√ü", "TSCH√ú·∫û", "tsch√º√ü", "tsch√ºss", "tsch√ºss",  ],
[ "ru√üland", "ru√üland", "Ru√üland", "RU√üLAND", "ru√üland", "Ru√üland", "RUSSLAND", "ru√üland", "russland", "russland",  ],
[ "RU·∫ûLAND", "ru√üland", "Ru√üland", "RU·∫ûLAND", "ru√üland", "Ru√üland", "RU·∫ûLAND", "ru√üland", "russland", "russland",  ],
[ "wei√ü", "wei√ü", "Wei√ü", "WEI√ü", "wei√ü", "Wei√ü", "WEISS", "wei√ü", "weiss", "weiss",  ],
[ "WEI·∫û", "wei√ü", "Wei√ü", "WEI·∫û", "wei√ü", "Wei√ü", "WEI·∫û", "wei√ü", "weƒ±ss", "weiss",  ],
[ "·∫ûIEW", "√üiew", "·∫ûiew", "·∫ûIEW", "√üiew", "·∫ûiew", "·∫ûIEW", "√üiew", "ssƒ±ew", "ssiew",  ],
[ "ÕÖ", "ÕÖ", "Œô", "Œô", "ÕÖ", "Œô", "Œô", "Œπ", "Œπ", "Œπ",  ],
[ "Œ±ÃÄÕÖ", "Œ±ÃÄÕÖ", "ŒëÃÄÕÖ", "ŒëÃÄŒô", "Œ±ÃÄÕÖ", "ŒëÃÄÕÖ", "ŒëÃÄŒô", "Œ±ÃÄŒπ", "Œ±ÃÄŒπ", "Œ±ÃÄŒπ",  ],
[ "·æ∫Œπ", "·Ω∞Œπ", "·æ∫Œπ", "·æ∫Œô", "·Ω∞Œπ", "·æ∫Œπ", "·æ∫Œô", "·Ω∞Œπ", "·Ω∞Œπ", "·Ω∞Œπ",  ],
[ "·æ∫Œô", "·Ω∞Œπ", "·æ∫Œπ", "·æ∫Œô", "·Ω∞Œπ", "·æ∫Œπ", "·æ∫Œô", "·Ω∞Œπ", "·Ω∞Œπ", "·Ω∞Œπ",  ],
[ "·æ≤", "·æ≤", "·æ≤", "·æ≤", "·æ≤", "·æ∫ÕÖ", "·æ∫Œô", "·æ≤", "·Ω∞Œπ", "·Ω∞Œπ",  ],
[ "·æ∫ÕÖ", "·Ω∞ÕÖ", "·æ∫ÕÖ", "·æ∫Œô", "·Ω∞ÕÖ", "·æ∫ÕÖ", "·æ∫Œô", "·Ω∞Œπ", "·Ω∞Œπ", "·Ω∞Œπ",  ],
[ "·æ∫Œô", "·Ω∞Œπ", "·æ∫Œπ", "·æ∫Œô", "·Ω∞Œπ", "·æ∫Œπ", "·æ∫Œô", "·Ω∞Œπ", "·Ω∞Œπ", "·Ω∞Œπ",  ],
[ "·æ≤ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø", "·æ≤ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø", "·æ≤ Œ£œÑŒø ŒîŒπŒ¨ŒøŒªŒø", "·æ≤ Œ£Œ§Œü ŒîŒôŒÜŒüŒõŒü", "·æ≤ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø", "·æ∫ÕÖ Œ£œÑŒø ŒîŒπŒ¨ŒøŒªŒø", "·æ∫Œô Œ£Œ§Œü ŒîŒôŒÜŒüŒõŒü", "·æ≤ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø", "·Ω∞Œπ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø", "·Ω∞Œπ œÉœÑŒø Œ¥ŒπŒ¨ŒøŒªŒø",  ],
[ "Œ±ÃÄÕÖ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø", "Œ±ÃÄÕÖ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø", "ŒëÃÄÕÖ Œ£œÑŒø ŒîŒπŒ±ÃÅŒøŒªŒø", "ŒëÃÄŒô Œ£Œ§Œü ŒîŒôŒëÃÅŒüŒõŒü", "Œ±ÃÄÕÖ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø", "ŒëÃÄÕÖ Œ£œÑŒø ŒîŒπŒ±ÃÅŒøŒªŒø", "ŒëÃÄŒô Œ£Œ§Œü ŒîŒôŒëÃÅŒüŒõŒü", "Œ±ÃÄŒπ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø", "Œ±ÃÄŒπ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø", "Œ±ÃÄŒπ œÉœÑŒø Œ¥ŒπŒ±ÃÅŒøŒªŒø",  ],
[ "‚Ö∑", "‚Ö∑", "‚Öß", "‚Öß", "‚Ö∑", "‚Öß", "‚Öß", "‚Ö∑", "‚Ö∑", "‚Ö∑",  ],
[ "henry ‚Ö∑", "henry ‚Ö∑", "Henry ‚Öß", "HENRY ‚Öß", "henry ‚Ö∑", "Henry ‚Öß", "HENRY ‚Öß", "henry ‚Ö∑", "henry ‚Ö∑", "henry ‚Ö∑",  ],
[ "‚ìö", "‚ìö", "‚ìÄ", "‚ìÄ", "‚ìö", "‚ìÄ", "‚ìÄ", "‚ìö", "‚ìö", "‚ìö",  ],
[ "i work at ‚ìö", "i work at ‚ìö", "I Work At ‚ìÄ", "I WORK AT ‚ìÄ", "i work at ‚ìö", "I Work At ‚ìÄ", "I WORK AT ‚ìÄ", "i work at ‚ìö", "i work at ‚ìö", "i work at ‚ìö",  ],
[ "istambul", "istambul", "Istambul", "ISTAMBUL", "istambul", "Istambul", "ISTAMBUL", "istambul", "istambul", "istambul",  ],
[ "iÃástanbul", "iÃástanbul", "IÃástanbul", "IÃáSTANBUL", "iÃástanbul", "IÃástanbul", "IÃáSTANBUL", "iÃástanbul", "iÃástanbul", "iÃástanbul",  ],
[ "IÃástanbul", "iÃástanbul", "IÃástanbul", "IÃáSTANBUL", "iÃástanbul", "IÃástanbul", "IÃáSTANBUL", "iÃástanbul", "ƒ±Ãástanbul", "iÃástanbul",  ],
[ "ƒ∞STANBUL", "istanbul", "ƒ∞stanbul", "ƒ∞STANBUL", "iÃástanbul", "ƒ∞stanbul", "ƒ∞STANBUL", "ƒ∞stanbul", "istanbul", "iÃástanbul",  ],
[ "œÉœÑŒπŒ≥ŒºŒ±œÇ", "œÉœÑŒπŒ≥ŒºŒ±œÇ", "Œ£œÑŒπŒ≥ŒºŒ±œÇ", "Œ£Œ§ŒôŒìŒúŒëŒ£", "œÉœÑŒπŒ≥ŒºŒ±œÇ", "Œ£œÑŒπŒ≥ŒºŒ±œÇ", "Œ£Œ§ŒôŒìŒúŒëŒ£", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "œÉœÑŒπŒ≥ŒºŒ±œÉ",  ],
[ "œÉœÑŒπŒ≥ŒºŒ±œÉ", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "Œ£œÑŒπŒ≥ŒºŒ±œÉ", "Œ£Œ§ŒôŒìŒúŒëŒ£", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "Œ£œÑŒπŒ≥ŒºŒ±œÉ", "Œ£Œ§ŒôŒìŒúŒëŒ£", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "œÉœÑŒπŒ≥ŒºŒ±œÉ",  ],
[ "Œ£Œ§ŒôŒìŒúŒëŒ£", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "Œ£œÑŒπŒ≥ŒºŒ±œÉ", "Œ£Œ§ŒôŒìŒúŒëŒ£", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "Œ£œÑŒπŒ≥ŒºŒ±œÉ", "Œ£Œ§ŒôŒìŒúŒëŒ£", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "œÉœÑŒπŒ≥ŒºŒ±œÉ", "œÉœÑŒπŒ≥ŒºŒ±œÉ",  ],
[ " Ä·¥Ä Ä·¥á", " Ä·¥Ä Ä·¥á", "∆¶·¥Ä Ä·¥á", "∆¶·¥Ä∆¶·¥á", " Ä·¥Ä Ä·¥á", "∆¶·¥Ä Ä·¥á", "∆¶·¥Ä∆¶·¥á", " Ä·¥Ä Ä·¥á", " Ä·¥Ä Ä·¥á", " Ä·¥Ä Ä·¥á",  ],
[ "êêºêêØêëÖêê®êëâêêØêêª", "êêºêêØêëÖêê®êëâêêØêêª", "êêîêêØêëÖêê®êëâêêØêêª", "êêîêêáêêùêêÄêê°êêáêêì", "êêºêêØêëÖêê®êëâêêØêêª", "êêîêêØêëÖêê®êëâêêØêêª", "êêîêêáêêùêêÄêê°êêáêêì", "êêºêêØêëÖêê®êëâêêØêêª", "êêºêêØêëÖêê®êëâêêØêêª", "êêºêêØêëÖêê®êëâêêØêêª",  ],
[ "‘¶‘ß", "‘ß‘ß", "‘¶‘ß", "‘¶‘¶", "‘ß‘ß", "‘¶‘ß", "‘¶‘¶", "‘ß‘ß", "‘ß‘ß", "‘ß‘ß",  ],
[ "Ô¨ìÔ¨îÔ¨ïÔ¨ñÔ¨ó", "Ô¨ìÔ¨îÔ¨ïÔ¨ñÔ¨ó", "Ô¨ìÔ¨îÔ¨ïÔ¨ñÔ¨ó", "Ô¨ìÔ¨îÔ¨ïÔ¨ñÔ¨ó", "Ô¨ìÔ¨îÔ¨ïÔ¨ñÔ¨ó", "’Ñ’∂Ô¨îÔ¨ïÔ¨ñÔ¨ó", "’Ñ’Ü’Ñ‘µ’Ñ‘ª’é’Ü’Ñ‘Ω", "Ô¨ìÔ¨îÔ¨ïÔ¨ñÔ¨ó", "’¥’∂’¥’•’¥’´’æ’∂’¥’≠", "’¥’∂’¥’•’¥’´’æ’∂’¥’≠",  ],
[ "≈â groot", "≈â groot", "≈â Groot", "≈â GROOT", "≈â groot", " ºN Groot", " ºN GROOT", "≈â groot", " ºn groot", " ºn groot",  ],
[ "·∫ö", "·∫ö", "·∫ö", "·∫ö", "·∫ö", "A æ", "A æ", "·∫ö", "a æ", "a æ",  ],
[ "Ô¨Ä", "Ô¨Ä", "Ô¨Ä", "Ô¨Ä", "Ô¨Ä", "Ff", "FF", "Ô¨Ä", "ff", "ff",  ],
[ "«∞", "«∞", "«∞", "«∞", "«∞", "JÃå", "JÃå", "«∞", "jÃå", "jÃå",  ],
[ "550 nm or ‚Ñ´", "550 nm or √•", "550 Nm Or ‚Ñ´", "550 NM OR ‚Ñ´", "550 nm or √•", "550 Nm Or ‚Ñ´", "550 NM OR ‚Ñ´", "550 nm or √•", "550 nm or √•", "550 nm or √•",  ],
);

    use feature qw(fc);

    for (@test_table) {
        my ($simple_lc, $simple_tc, $simple_uc, $simple_fc) = @{$_}[1, 2, 3, 7];
        my ($orig, $lower, $titlecase, $upper, $fc_turkic, $fc_full) = @{$_}[0,4,5,6,8,9];

        if ($orig =~ /(\P{Assigned})/) {   # So can fail gracefully in earlier
                                           # Unicode versions
            fail(sprintf "because U+%04X is unassigned", ord($1));
            next;
        }
        is( fc($orig), $fc_full, "fc('$orig') returns '$fc_full'" );
        is( "\F$orig", $fc_full, '\F works' );
        is( lc($orig), $lower,   "lc('$orig') returns '$lower'" );
        is( "\L$orig", $lower,   '\L works' );
        is( uc($orig), $upper,   "uc('$orig') returns '$upper'" );
        is( "\U$orig", $upper,   '\U works' );
    }
}

{
    use feature qw(fc);
    package Eeyup  { use overload q{""} => sub { main::uni_to_native("\x{df}")   }, fallback => 1 }
    package Uunope { use overload q{""} => sub { "\x{30cb}" }, fallback => 1 }
    package Undef  { use overload q{""} => sub {   undef    }, fallback => 1 }

    my $obj = bless {}, "Eeyup";
    is(fc($obj), "ss", "fc() works on overloaded objects returning latin-1");
    $obj = bless {}, "Eeyup";
    is("\F$obj", "ss", '\F works on overloaded objects returning latin-1');

    $obj = bless {}, "Uunope";
    is(fc($obj), "\x{30cb}", "fc() works on overloaded objects returning UTF-8");
    $obj = bless {}, "Uunope";
    is("\F$obj", "\x{30cb}", '\F works on overloaded objects returning UTF-8');

    $obj = bless {}, "Undef";
    my $warnings;
    {
        no warnings;
        use warnings "uninitialized";
        local $SIG{__WARN__} = sub { $warnings++; like(shift, qr/Use of uninitialized value (?:\$obj )?in fc/) };
        fc(undef);
        fc($obj);
    }
    is( $warnings, 2, "correct number of warnings" );

    my $fetched = 0;
    package Derpy { sub TIESCALAR { bless {}, shift } sub FETCH { $fetched++; main::uni_to_native("\x{df}") } }

    tie my $x, "Derpy";

    is( fc($x), "ss", "fc() works on tied values" );
    is( $fetched, 1, "and only calls the magic once" );

}

{
    use feature qw( fc );
    my $troublesome1 = uni_to_native("\xdf") x 11; #SvLEN should be 12, SvCUR should be 11
                                    #So this should force fc() to grow the string.

    is( fc($troublesome1), "ss" x 11, "fc() grows the string" );

    my $troublesome2 = "abcdef:" . uni_to_native("\x{df}")
                     . ":fjksjs"; #SvLEN should be 16, SvCUR should be 15
    is( fc($troublesome2), "abcdef:ss:fjksjs", "fc() expands \\x{DF} in the middle of a string that needs to grow" );

    my $troublesome3 = ":" . uni_to_native("\x{df}") . ":";
    is( fc($troublesome3), ":ss:", "fc() expands \\x{DF} in the middle of a string" );


    my $troublesome4 = uni_to_native("\x{B5}"); #\N{MICRON SIGN} is latin-1, but its foldcase is in UTF-8

    is( fc($troublesome4), "\x{3BC}", "fc() for a latin-1 \x{B5} returns UTF-8" );
    ok( !utf8::is_utf8($troublesome4), "fc() doesn't upgrade the original string" );


    my $troublesome5 = uni_to_native("\x{C9}") . "abda"
                     . uni_to_native("\x{B5}") . "aaf"
                     . uni_to_native("\x{C8}");  # Up until foldcasing \x{B5}, the string
                                                    # was in Latin-1. This tests that the
                                                    # results don't have illegal UTF-8
                                                    # (i.e. leftover latin-1) in them

    is( fc($troublesome5), uni_to_native("\x{E9}") . "abda\x{3BC}aaf"
                         . uni_to_native("\x{E8}") );
}


SKIP: {
    use feature qw( fc unicode_strings );

    skip "locales not available", 256 unless locales_enabled('LC_ALL');

    setlocale(&POSIX::LC_ALL, "C");

    # This tests both code paths in pp_fc

    for (0..0xff) {
        my $latin1 = chr;
        my $utf8   = $latin1;
        utf8::downgrade($latin1); #No-op, but doesn't hurt
        utf8::upgrade($utf8);
        is(fc($latin1), fc($utf8), "fc() gives the same results for \\x{$_} in Latin-1 and UTF-8 under unicode_strings");
        SKIP: {
            skip 'Locales not available', 2 unless locales_enabled('LC_CTYPE');
            use locale;
            is(fc($latin1), lc($latin1), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
            is(fc($utf8), lc($utf8), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
        }
        {
            no feature 'unicode_strings';
            is(fc($latin1), lc($latin1), "under nothing, fc() for <256 is the same as lc");
        }
    }
}

my $utf8_locale = find_utf8_ctype_locale();

{
    use feature qw( fc );
    use locale;
    no warnings 'locale';   # Would otherwise warn
    is(fc("\x{1E9E}"), fc("\x{17F}\x{17F}"), 'fc("\x{1E9E}") eq fc("\x{17F}\x{17F}")');
    use warnings 'locale';
    SKIP: {
        skip 'Can\'t find a UTF-8 locale', 1 unless defined $utf8_locale;
        setlocale(&LC_CTYPE, $utf8_locale);
        is(fc("\x{1E9E}"), "ss", 'fc("\x{1E9E}") eq "ss" in a UTF-8 locale)');
    }
}

SKIP: {
    skip 'Can\'t find a UTF-8 locale', 256 unless defined $utf8_locale;

    use feature qw( fc unicode_strings );

    # Get the official fc values outside locale.
    no locale;
    my @unicode_fc;
    for (0..0xff) {
        push @unicode_fc, fc(chr);
    }

    # These should match the UTF-8 locale values
    setlocale(&LC_CTYPE, $utf8_locale);
    use locale;
    for (0..0xff) {
        is(fc(chr), $unicode_fc[$_], "In a UTF-8 locale, fc(chr $_) is the same as official Unicode");
    }
}


my $num_tests = curr_test() - 1;

plan($num_tests);
