Perl -Sx "{0}" {"Parameters"}
Exit 0

#!perl -s

use Pod::Parser;

package MyPodParseLink;

##############################################################################
# Since Pod::ParseLink is (a) not part of the standard library prior to Perl 
# 5.8, and (b) I needed to make a little change for compatibility with Shuck,  
# its code was copied over here. All credits go to Russ Allbery.
##############################################################################

# Parse the name and section portion of a link into a name and section.
sub _parse_section {
    my ($link) = @_;
    $link =~ s/^\s+//;
    $link =~ s/\s+$//;

    # If the whole link is enclosed in quotes, interpret it all as a section
    # even if it contains a slash.
    return (undef, $1) if ($link =~ /^"\s*(.*?)\s*"$/);

    # Split into page and section on slash, and then clean up quoting in the
    # section.  If there is no section and the name contains spaces, also
    # guess that it's an old section link.
    my ($page, $section) = split (/\s*\/\s*/, $link, 2);
    $section =~ s/^"\s*(.*?)\s*"$/$1/ if $section;
    if ($page && $page =~ / / && !defined ($section)) {
        $section = $page;
        $page = undef;
    } else {
        $page = undef unless $page;
        $section = undef unless $section;
    }
    return ($page, $section);
}

# Infer link text from the page and section.
sub _infer_text {
    my ($page, $section) = @_;
    my $inferred;
    if ($page && !$section) {
        $inferred = $page;
    } elsif (!$page && $section) {
        $inferred = '"' . $section . '"';
    } elsif ($page && $section) {
	    # The string 'the section ' string is prepended for compatibility with 
		# Shuck (this is the only difference from Pod::ParseLink)
        $inferred = 'the section ' . '"' . $section . '" in ' . $page; 
    }
    return $inferred;
}

# Given the contents of an L<> formatting code, parse it into the link text,
# the possibly inferred link text, the name or URL, the section, and the type
# of link (pod, man, or url).
sub parselink {
    my ($link) = @_;
    $link =~ s/\s+/ /g;
    if ($link =~ /\A\w+:[^:\s]\S*\Z/) {
        return (undef, $link, $link, undef, 'url');
    } else {
        my $text;
        if ($link =~ /\|/) {
            ($text, $link) = split (/\|/, $link, 2);
        }
        my ($name, $section) = _parse_section ($link);
        my $inferred = $text || _infer_text ($name, $section);
        my $type = ($name && $name =~ /\(\S*\)/) ? 'man' : 'pod';
        return ($text, $inferred, $name, $section, $type);
    }
}


##############################################################################
# And now our Pod::Parser subclass, MyPodIndexer
# (A lot of this code was borrowed from Pod::Text, credits to Russ Allbery.)
##############################################################################
package MyPodIndexer;
@ISA = qw(Pod::Parser);

# Table of supported E<> escapes for the Macintosh standard Roman character set.
# (These are exactly the same escapes as known by Shuck. This list is incomplete
# since the Macintosh standard Roman character set doesn't contain all characters
# defined in the ISO 8559-1 (Latin 1) character set.)
%ESCAPES = (
    'amp'       =>    '&',       # ampersand
    'apos'      =>    "'",       # apostrophe
    'lt'        =>    '<',       # left chevron, less-than
    'gt'        =>    '>',       # right chevron, greater-than
    'quot'      =>    '"',       # double quote
    'sol'       =>    '/',       # solidus (forward slash)
    'verbar'    =>    '|',       # vertical bar

    "Aacute"    =>    "ç",       # capital A, acute accent
    "aacute"    =>    "‡",       # small a, acute accent
    "Acirc"     =>    "å",       # capital A, circumflex accent
    "acirc"     =>    "‰",       # small a, circumflex accent
    "AElig"     =>    "®",       # capital AE diphthong (ligature)
    "aelig"     =>    "¾",       # small ae diphthong (ligature)
    "Agrave"    =>    "Ë",       # capital A, grave accent
    "agrave"    =>    "ˆ",       # small a, grave accent
    "Aring"     =>    "",       # capital A, ring
    "aring"     =>    "Œ",       # small a, ring
    "Atilde"    =>    "Ì",       # capital A, tilde
    "atilde"    =>    "‹",       # small a, tilde
    "Auml"      =>    "€",       # capital A, dieresis or umlaut mark
    "auml"      =>    "Š",       # small a, dieresis or umlaut mark
    "Ccedil"    =>    "‚",       # capital C, cedilla
    "ccedil"    =>    "",       # small c, cedilla
    "Eacute"    =>    "ƒ",       # capital E, acute accent
    "eacute"    =>    "Ž",       # small e, acute accent
    "Ecirc"     =>    "æ",       # capital E, circumflex accent
    "ecirc"     =>    "",       # small e, circumflex accent
    "Egrave"    =>    "é",       # capital E, grave accent
    "egrave"    =>    "",       # small e, grave accent
    "ETH"       =>    "Eth",     # capital Eth, Icelandic
    "eth"       =>    "eth",     # small eth, Icelandic
    "Euml"      =>    "è",       # capital E, dieresis or umlaut mark
    "euml"      =>    "‘",       # small e, dieresis or umlaut mark
    "Iacute"    =>    "ê",       # capital I, acute accent
    "iacute"    =>    "’",       # small i, acute accent
    "Icirc"     =>    "ë",       # capital I, circumflex accent
    "icirc"     =>    "”",       # small i, circumflex accent
    "Igrave"    =>    "í",       # capital I, grave accent
    "igrave"    =>    "“",       # small i, grave accent
    "Iuml"      =>    "ì",       # capital I, dieresis or umlaut mark
    "iuml"      =>    "•",       # small i, dieresis or umlaut mark
    "Ntilde"    =>    "„",       # capital N, tilde
    "ntilde"    =>    "–",       # small n, tilde
    "Oacute"    =>    "î",       # capital O, acute accent
    "oacute"    =>    "—",       # small o, acute accent
    "Ocirc"     =>    "ï",       # capital O, circumflex accent
    "ocirc"     =>    "™",       # small o, circumflex accent
    "Ograve"    =>    "ñ",       # capital O, grave accent
    "ograve"    =>    "˜",       # small o, grave accent
    "Oslash"    =>    "¯",       # capital O, slash
    "oslash"    =>    "¿",       # small o, slash
    "Otilde"    =>    "Í",       # capital O, tilde
    "otilde"    =>    "›",       # small o, tilde
    "Ouml"      =>    "…",       # capital O, dieresis or umlaut mark
    "ouml"      =>    "š",       # small o, dieresis or umlaut mark
    "szlig"     =>    "§",       # small sharp s, German (sz ligature)
    "THORN"     =>    "Thorn",   # capital THORN, Icelandic
    "thorn"     =>    "thorn",   # small thorn, Icelandic
    "Uacute"    =>    "ò",       # capital U, acute accent
    "uacute"    =>    "œ",       # small u, acute accent
    "Ucirc"     =>    "ó",       # capital U, circumflex accent
    "ucirc"     =>    "ž",       # small u, circumflex accent
    "Ugrave"    =>    "ô",       # capital U, grave accent
    "ugrave"    =>    "",       # small u, grave accent
    "Uuml"      =>    "†",       # capital U, dieresis or umlaut mark
    "uuml"      =>    "Ÿ",       # small u, dieresis or umlaut mark
    "Yacute"    =>    "«Y",      # capital Y, acute accent
    "yacute"    =>    "«y",      # small y, acute accent
    "yuml"      =>    "Ø",       # small y, dieresis or umlaut mark

    "laquo"     =>    "Ç",       # left pointing double angle quotation mark
    "lchevron"  =>    "Ç",       #  synonym (backwards compatibility)
    "raquo"     =>    "È",       # right pointing double angle quotation mark
    "rchevron"  =>    "È",       #  synonym (backwards compatibility)

    "iexcl"     =>    "Á",       # inverted exclamation mark
    "cent"      =>    "¢",       # cent sign
    "pound"     =>    "£",       # (UK) pound sign

    "yen"       =>    "´",       # yen sign

    "sect"      =>    "¤",       # section sign
    "uml"       =>    "¬",       # diaresis
    "copy"      =>    "©",       # Copyright symbol
    "ordf"      =>    "»",       # feminine ordinal indicator
	"not"       =>    "Â",       # not sign
	
    "reg"       =>    "¨",       # registered trademark
    "macr"      =>    "ø",       # macron, overline
    "deg"       =>    "¡",       # degree sign
    "plusmn"    =>    "±",       # plus-minus sign

    "acute"     =>    "«",       # acute accent
    "micro"     =>    "µ",       # micro sign
    "para"      =>    "¦",       # pilcrow sign = paragraph sign
    "middot"    =>    "á",       # middle dot = Georgian comma
    "cedil"     =>    "ü",       # cedilla

    "ordm"      =>    "¼",       # masculine ordinal indicator

    "iquest"    =>    "À",       # inverted question mark
    "times"     =>    "x",       # multiplication sign (just an x)
    "divide"    =>    "Ö",       # division sign

    "nbsp"      =>    "Ê",       # non-breaking space
);


# This array maps the ISO 8559-1 (Latin-1) character set to the Mac standard Roman character set.
# Latin 1: The first 127 characters are equal to ASCII. (0x00 - 0x7F,   0 - 127, where 127 is non-printable)
#          The next 32 characters are non-printable.	(0x80 - 0x9F, 128 - 159) 
#		   The last 96 characters are shown below.      (0xA0 - 0xFF, 160 - 255)
#
# (subtract 160 from the Latin-1 char code to get the array index)
@Latin1_to_MacRoman_MAP = ( 

		0xCA,		#  0 -- 0xA0, 160, ' '		-> nonbreaking space
		0xC1,		#  1 -- 0xA1, 161, 'Á' 		-> inverted exclamation mark
		0xA2,		#  2 -- 0xA2, 162, '¢'		-> cent sign
		0xA3,		#  3 -- 0xA3, 163, '£'		-> (UK) pound sign
		0xDB,		#  4 -- 0xA4, 164, 'Û'		-> currency sign (some fonts display it as Euro sign; select e.g. Futura to see it)
		0xB4,		#  5 -- 0xA5, 165, '´' 		-> yen sign
		0x00,		#  6 -- 0xA6, 166, n/a		-> broken vertical bar (not in the Mac standard Roman character set)
		0xA4,		#  7 -- 0xA7, 167, '¤'		-> section sign
		0xAC,		#  8 -- 0xA8, 168, '¬'		-> diaresis
		0xA9,		#  9 -- 0xA9, 169, '©'		-> Copyright symbol

		0xBB,		# 10 -- 0xAA, 170, '»'		-> feminine ordinal indicator		
		0xC7,		# 11 -- 0xAB, 171, 'Ç'		-> left pointing double angle quotation mark, guillemotleft
		0xC2,		# 12 -- 0xAC, 172, 'Â'		-> (logical) not sign
		0xD0,		# 13 -- 0xAD, 173, 'Ð'		-> soft (discretionary) hyphen (endash)
		0xA8,		# 14 -- 0xAE, 174, '¨'		-> registered
		0xF8,		# 15 -- 0xAF, 175, 'ø'		-> macron, overline
		0xA1,		# 16 -- 0xB0, 176, '¡'		-> degree sign
		0xB1,		# 17 -- 0xB1, 177, '±'		-> plus-minus sign
		0x00,		# 18 -- 0xB2, 178, n/a		-> superscript 2 (not in the Mac standard Roman character set)
		0x00,		# 19 -- 0xB3, 179, n/a		-> superscript 3 (not in the Mac standard Roman character set)

		0xAB,		# 20 -- 0xB4, 180, '«'		-> acute accent
		0xB5,		# 21 -- 0xB5, 181, 'µ'		-> micro sign
		0xA6,		# 22 -- 0xB6, 182, '¦'		-> pilcrow sign = paragraph sign
		0xE1,		# 23 -- 0xB7, 183, 'á'		-> middle dot or periodcentered = Georgian comma
		0xFC,		# 24 -- 0xB8, 184, 'ü'		-> cedilla
		0x00,		# 25 -- 0xB9, 185, n/a		-> superscript 1 (not in the Mac standard Roman character set)
		0xBC,		# 26 -- 0xBA, 186, '¼'		-> masculine ordinal indicator
		0xC8,		# 27 -- 0xBB, 187, 'È'		-> right pointing double angle quotation mark, guillemotright
		0x00,		# 28 -- 0xBC, 188, n/a		-> vulgar fraction one quarter (not in the Mac standard Roman character set)
		0x00,		# 29 -- 0xBD, 189, n/a		-> vulgar fraction one half (not in the Mac standard Roman character set)

		0x00,		# 30 -- 0xBE, 190, n/a		-> vulgar fraction three quarters (not in the Mac standard Roman character set)
		0xC0,		# 31 -- 0xBF, 191, 'À'		-> inverted question mark
		0xCB,		# 32 -- 0xC0, 192, 'Ë'		-> capital A, grave accent
		0xE7,		# 33 -- 0xC1, 193, 'ç'		-> capital A, acute accent
		0xE5,		# 34 -- 0xC2, 194, 'å'		-> capital A, circumflex accent
		0xCC,		# 35 -- 0xC3, 195, 'Ì'		-> capital A, tilde
		0x80,		# 36 -- 0xC4, 196, '€'		-> capital A, dieresis or umlaut mark
		0x81,		# 37 -- 0xC5, 197, ''		-> capital A, ring
		0xAE,		# 38 -- 0xC6, 198, '®'		-> capital AE diphthong (ligature)
		0x82,		# 39 -- 0xC7, 199, '‚'		-> capital C, cedilla
		
		0xE9,		# 40 -- 0xC8, 200, 'é'		-> capital E, grave accent
		0x83,		# 41 -- 0xC9, 201, 'ƒ'		-> capital E, acute accent
		0xE6,		# 42 -- 0xCA, 202, 'æ'		-> capital E, circumflex accent
		0xE8,		# 43 -- 0xCB, 203, 'è'		-> capital E, dieresis or umlaut mark
		0xED,		# 44 -- 0xCC, 204, 'í'		-> capital I, grave accent
		0xEA,		# 45 -- 0xCD, 205, 'ê'		-> capital I, acute accent
		0xEB,		# 46 -- 0xCE, 206, 'ë'		-> capital I, circumflex accent
		0xEC,		# 47 -- 0xCF, 207, 'ì'		-> capital I, dieresis or umlaut mark		
		0x00,		# 48 -- 0xD0, 208, n/a		-> capital Eth, Icelandic (not in the Mac standard Roman character set)
		0x84,		# 49 -- 0xD1, 209, '„'		-> capital N, tilde

		0xF1,		# 50 -- 0xD2, 210, 'ñ'		-> capital O, grave accent
		0xEE,		# 51 -- 0xD3, 211, 'î'		-> capital O, acute accent
		0xEF,		# 52 -- 0xD4, 212, 'ï'		-> capital O, circumflex accent
		0xCD,		# 53 -- 0xD5, 213, 'Í'		-> capital O, tilde
		0x85,		# 54 -- 0xD6, 214, '…'		-> capital O, dieresis or umlaut mark
		0x00,		# 55 -- 0xD7, 215, n/a		-> multiplication sign (not in the Mac standard Roman character set)
		0xAF,		# 56 -- 0xD8, 216, '¯'		-> capital O, slash
		0xF4,		# 57 -- 0xD9, 217, 'ô'		-> capital U, grave accent
		0xF2,		# 58 -- 0xDA, 218, 'ò'		-> capital U, acute accent
		0xF3,		# 59 -- 0xDB, 219, 'ó'		-> capital U, circumflex accent
		
		0x86,		# 60 -- 0xDC, 220, '†'		-> capital U, dieresis or umlaut mark
		0x00,		# 61 -- 0xDD, 221, n/a		-> capital Y, acute accent (not in the Mac standard Roman character set)
		0x00,		# 62 -- 0xDE, 222, n/a		-> capital THORN, Icelandic (not in the Mac standard Roman character set)
		0xA7,		# 63 -- 0xDF, 223, '§'		-> small sharp s, German (sz ligature)
		0x88,		# 64 -- 0xE0, 224, 'ˆ'		-> small a, grave accent
		0x87,		# 65 -- 0xE1, 225, '‡'		-> small a, acute accent
		0x89,		# 66 -- 0xE2, 226, '‰'		-> small a, circumflex accent
		0x8B,		# 67 -- 0xE3, 227, '‹'		-> small a, tilde
		0x8A,		# 69 -- 0xE4, 228, 'Š'		-> small a, dieresis or umlaut mark
		0x8C,		# 69 -- 0xE5, 229, 'Œ'		-> small a, ring

		0xBE,		# 70 -- 0xE6, 230, '¾'		-> small ae diphthong (ligature)
		0x8D,		# 71 -- 0xE7, 231, ''		-> small c, cedilla
		0x8F,		# 72 -- 0xE8, 232, ''		-> small e, grave accent
		0x8E,		# 73 -- 0xE9, 233, 'Ž'		-> small e, acute accent
		0x90,		# 74 -- 0xEA, 234, ''		-> small e, circumflex accent
		0x91,		# 75 -- 0xEB, 235, '‘'		-> small e, dieresis or umlaut mark
		0x93,		# 76 -- 0xEC, 236, '“'		-> small i, grave accent	
		0x92,		# 77 -- 0xED, 237, '’'		-> small i, acute accent
		0x94,		# 78 -- 0xEE, 238, '”'		-> small i, circumflex accent
		0x95,		# 79 -- 0xEF, 239, '•'		-> small i, dieresis or umlaut mark

		0x00,		# 80 -- 0xF0, 240, n/a		-> small eth, Icelandic (not in the Mac standard Roman character set)
		0x96,		# 81 -- 0xF1, 241, '–'		-> small n, tilde
		0x98,		# 82 -- 0xF2, 242, '˜'		-> small o, grave accent
		0x97,		# 83 -- 0xF3, 243, '—'		-> small o, acute accent
		0x99,		# 84 -- 0xF4, 244, '™'		-> small o, circumflex accent
		0x9B,		# 85 -- 0xF5, 245, '›'		-> small o, tilde
		0xBB,		# 86 -- 0xF6, 246, 'š'		-> small o, dieresis or umlaut mark		
		0xD6,		# 87 -- 0xF7, 247, 'Ö'		-> division sign
		0xBF,		# 88 -- 0xF8, 248, '¿'		-> small o, slash
		0x9D,		# 89 -- 0xF9, 249, ''		-> small u, grave accent

		0x9C,		# 90 -- 0xFA, 250, 'œ'		-> small u, acute accent
		0x9E,		# 91 -- 0xFB, 251, 'ž'		-> small u, circumflex accent
		0x9F,		# 92 -- 0xFC, 252, 'Ÿ'		-> small u, dieresis or umlaut mark
		0x00,		# 93 -- 0xFD, 253, n/a		-> small y, acute accent (not in the Mac standard Roman character set)
		0x00,		# 94 -- 0xFE, 254, n/a		-> small thorn, Icelandic (not in the Mac standard Roman character set)
		0xD8		# 95 -- 0xFF, 255, 'Ø'		-> small y, dieresis or umlaut mark

);

	
	
sub command {
	my ($parser, $command, $paragraph, $line_num) = @_;
	my $out_fh = $parser->output_handle();
	my $expansion;
	
	# interpret the command and its text 
	# for indexing, only =heads and =items are of interest
	if ( ($command eq 'head1') || ($command eq 'head2') ||
	     ($command eq 'head3') || ($command eq 'head4') ||
	     ($command eq 'item') )  
	{
		# expand formatting codes
		$expansion = $parser->interpolate($paragraph, $line_num);
		# print to out file
		print $out_fh '=' . $command . '    ' . $expansion;
	}
}

sub verbatim {
	my ($parser, $paragraph, $line_num) = @_;        
	# do nothing
}

sub textblock {
	my ($parser, $paragraph, $line_num) = @_;       
	# do nothing
}


# Handle links. Most of the work is done by MyPodParseLink.
sub seq_Link {
    my ($self, $link, $seq) = @_;
    my ($text, $type) = (MyPodParseLink::parselink ($link))[1,4];
    my ($file, $line) = $seq->file_line;
    $text = $self->interpolate ($text, $line);
    $text = '<' . $text . '>' if $type eq 'url';
    return $text || '';
}

# Called for a formatting code. Gets the command, argument, and a
# Pod::InteriorSequence object and is expected to return the resulting text.
sub interior_sequence {
	my ($parser, $seq_command, $seq_argument, $pod_seq) = @_;

	my $parent = $pod_seq->nested;
    while (defined $parent) {
        return $pod_seq->raw_text if ($parent->cmd_name eq 'L');
        $parent = $parent->nested;
    }
	
	# get filename and line number 
	my ($file, $line) = $pod_seq->file_line;

    # Index entries are ignored in plain text.
    return '' if ($seq_command eq 'X' || $seq_command eq 'Z');
	
	# Expand escapes into the actual character now, warning if invalid.
    if ($seq_command eq 'E') {
       	
		my $is_Number = 0;
	   	if    ( $seq_argument =~ m/^(0x[a-fA-F0-9]+)$/ ) {		
			# hexadecimal
			$charCode = hex($1);
			$is_Number = 1;
		}
		elsif ( $seq_argument =~ m/^(0[0-7]+)$/ ) {
			# octal
			$charCode = oct($1);
			$is_Number = 1;
		}
		elsif ( $seq_argument =~ m/^(0|(?:[1-9][0-9]*))$/) {
			# decimal, but not e.g. 099
			$charCode = $1;
			$is_Number = 1;
		}
		
		if ($is_Number) { # $seq_argument is a character number
		
            if ( ($charCode < 0) || ($charCode > 255) ) {
				warn "$file:$line: Character code out of range: E<${seq_argument}>\n";
				return 'E<' . $seq_argument . '>';
			
			} 
			else {
	
				if ($charCode < 32)  { 
					# standard ASCII, non-printable			
					warn "$file:$line: Character is non-printable: E<${seq_argument}>\n";
					return 'E<' . $seq_argument . '>';
				}
				elsif ( ($charCode >= 32) && ($charCode < 127) ) { 
					# standard ASCII 
					return chr($charCode);					
				}
				elsif ( ($charCode >= 127) && ($charCode < 160) ) {
					# 127       : standard ASCII, but non-printable (DEL)
					# 128 - 159 : not defined in ISO 8559-1 (Latin-1)		
					warn "$file:$line: Character is non-printable: E<${seq_argument}>\n";
					return 'E<' . $seq_argument . '>';
				}
				else { 
					# 160 - 255 (0xA0 - 0xFF)
					# map ISO 8559-1 (Latin-1) to Mac standard Roman 
					my $MacCharCode = $Latin1_to_MacRoman_MAP[$charCode-160];
					if ($MacCharCode == 0) { 
						# not in Mac Roman
						warn "$file:$line: Character is not in the Macintosh standard Roman character set: E<${seq_argument}>\n";
						return 'E<' . $seq_argument . '>';				
					} 
					else {
						return chr($MacCharCode);
					}
				}
			}
		
		} 
		else {
            return $ESCAPES{$seq_argument} if defined $ESCAPES{$seq_argument};
            warn "$file:$line: Unknown escape: E<${seq_argument}>\n";
            return 'E<' . $seq_argument . '>';
        }
    }

    # For all the other formatting codes, empty content produces no output.
    return if $seq_argument eq '';
	
	# L gets dispatched to another method, anything else returns its argument 
    if    ($seq_command eq 'B') { return "$seq_argument";}
    elsif ($seq_command eq 'C') { return "$seq_argument"; }
    elsif ($seq_command eq 'F') { return "$seq_argument"; }
    elsif ($seq_command eq 'I') { return "$seq_argument"; }
	elsif ($seq_command eq 'S') { return "$seq_argument"; }
    elsif ($seq_command eq 'L') { return $parser->seq_Link ($seq_argument, $pod_seq) }
    else {
        warn "$file:$line: Unknown formatting code: $$seq_command<${seq_argument}>\n";
    }	
}


##############################################################################
# MAIN 
##############################################################################
package main;

($index = shift @ARGV) || die "No help index specified";

dbmopen(%INDEX, $index, 0666) || die "Couldn't open index file \"$index\"";

for (keys %INDEX) {
	delete $INDEX{$_};
}

while (<>) {
	if (/\@menu/) {
		&DoMenu();
	} elsif (/\@index\s+(\S+\.pod)/) {
		&DoPodIndex($1, $');
	} elsif (/\@index\s+(\S+)/) {
		&DoIndex($1, $');
	} elsif (/\@file\s+(\S+)\s+(\S+)/) {
		$INDEX{$1} = $2;
	} elsif (/\S+/) {
		die "Don't understand \"$&\"";
	}
}

if ($v) {
	print "-----\n";
	print $MENU;
	print "-----\n";

	for (sort keys %INDEX) {
		printf("%-20s %s\n", $_, $INDEX{$_});
	}
}

$INDEX{" MENU"} = $MENU;
MacPerl::SetFileInfo('McPL', 'HELP', $index);

dbmclose %INDEX;

sub DoMenu {
	$submenu = 0;
	while (<>) {
		if (/\@sep/) {
			$MENU .= "-(\t\n";
		} elsif (/\@sub\s+(\S.*\S)/) {
			$MENU .= "$1\t!\n";
			++$submenu;
		} elsif (/\@end/) {
			$MENU .= "\n";
			if (!$submenu--) {
				return;
			}
		} elsif (/(\S+)\s+(\S.*\S)/) {
			$MENU .= "$2\t$1\n";
		} elsif (/\S+/) {
			die "Don't understand \"$&\"";
		}
	}
	die "End of file while processing \@menu";
}

sub DoIndex {
	local($file, $var) = @_;
	local(%rename, %alias);
	
	$url = $file;
	if ($url =~ /^:/) {
		$url = $';
		$url =~ s|:|/|g;
		$url = "file:$url";
	} else {
		$url =~ s|:|/|g;		
		$url = "file://$url";
	}
	open(INDEX, $file) ||Êdie "Can't open index file \"$file\"";
	$var = ($var =~ /\@var/);
	while (<>) {
		if (/\@end/) {
			goto startindex;
		} elsif (/\@index/) {
			die "Forgot \@end";
		} elsif (/\@rename\s+(\S+)\s+(\S+)/) {
			warn "\"$2\" renamed both to \"$rename{$2}\" and \"$1\"" if $rename{$2};
			$rename{$2} = $1;
		} elsif (/\@alias\s+(\S+)\s+(\S+)/) {
			warn "\"$1\" already aliased to \"$alias{$1}\"" if $alias{$1};
			$alias{$1} = $2;
		} elsif (/\@delete\s+(\S+)/) {
			warn "\"$1\" both renamed to \"$rename{$1}\" and deleted" if $rename{$1};
			$rename{$1} = "";
		}
	}
	die "End of file while processing \@index";
startindex:
	while (<INDEX>) {
		next unless /NAME\s*=\s*\"([^"]+)\"/;
		($name,$_) = ($1, $');
		$key = $name;
		$key =~ s/^perl[a-z]*_//;
		if ($key =~ /_(\d+)/) {
			redo unless !$1;	# Ignore all except _0
			$key = $`;
		}
		$key = "\$\U$key\E" if $var;
		$key = $rename{$key} if defined $rename{$key};
		next unless $key;
		warn "\"$key\" already defined as \"$INDEX{$key}\", redefined as \"$url#$name\""
			if ($INDEX{$key} && $INDEX{$key} ne "$url#$name");
		$INDEX{$key} = "$url#$name";
	}
	while (($key,$value) = each(%alias)) {
		warn "\"$key\" already defined as \"$INDEX{$key}\", redefined as \"$INDEX{$value}\""
			if ($INDEX{$key} && $INDEX{$key} ne $INDEX{$value});
		warn "\"$value\" undefined" unless $INDEX{$value};
		$INDEX{$key} = $INDEX{$value};
	}
}

sub DoPodIndex {
	local($file, $var) = @_;
	local(%rename, %alias);
	
	# Create a parser object 
	my $parser = new MyPodIndexer(); 
	$file =~ m/([^:]+)\.pod$/;
	my $indexfile = $1 . '.idx'; # our temporary index file 

	# Read POD from file.pod and write to file.idx
	# (create the index file in our current directory, which normally is ":macperl_src:macperl:")
	$parser->parse_from_file ("::perl$file", ":$indexfile");
	
	$url = $file;
	if ($url =~ /^:/) {
		$url = $';
		$url =~ s|:|/|g;
		$url = "pod:$url";
	} else {
		$url =~ s|:|/|g;		
		$url = "pod://$url";
	}
	open(INDEX, ":$indexfile") ||Êdie "Can't open index file \"$indexfile\"";
	while (<>) {
		if (/\@end/) {
			goto startindex;
		} elsif (/\@index/) {
			die "Forgot \@end";
		} elsif (/\@rename\s+(\S+)\s+(.*\S)/) {
			warn "\"$2\" renamed both to \"$rename{$2}\" and \"$1\"" if $rename{$2};
			$rename{$2} = $1;
		} elsif (/\@alias\s+(\S+)\s+(.*\S)/) {
			warn "\"$1\" already aliased to \"$alias{$1}\"" if $alias{$1};
			$alias{$1} = $2;
		} elsif (/\@delete\s+(.*\S)/) {
			warn "\"$1\" both renamed to \"$rename{$1}\" and deleted" if $rename{$1};
			$rename{$1} = "";
		}
	}
	die "End of file while processing \@index";
startindex:
	while (<INDEX>) {
		if (/^=item\s+(.*\S)\s*$/) {
			$name = $1;
			
			# bullet lists and numbered lists are not indexed by Shuck
			next if ($name eq "*");              	# skip =item *
			next if ($name =~ m/^\d+\.?$/);      	# skip =item 1/2./0377   (decimal, octal)
			next if ($name =~ m/^0x[0-9a-fA-F]+$/); # skip =item 0x20        (hex)
			next if ($name =~ m/^0b[01]+$/);     	# skip =item 0b1100      (binary)
			
			if ($name =~ /^\$([A-Za-z_]+|\^[A-Z]|<I<digit>>|.)(.?)/) {
				if ($2 eq "{") {
					$key = "\%$1";
				} elsif ($2 eq "[") {
					$key = "\@$1";
				} else {
					$key = "\$$1";
				}
			} elsif ($name =~ /^([$@%](?:[A-Za-z_]+|\^[A-Z]|<I<digit>>|.))/) {
				$key = $1;
			} elsif ($name =~ /^([A-Za-z0-9_:]+|(?:-[A-Za-z]))/) {
				$key = $1;
			}Êelsif ($name =~ /^([^( ]+)/) {
				$key = $1;
			} else {
				next;
			}
		} elsif (/^=head\d\s+(.*\S)\s*$/) {
			$name = $1;
			next if $name =~ /^[A-Z]+$/ && !defined $rename{$name}; # Skip NAME etc.
			$key = $name;
		} else {
			next;
		}
		$name =~ s/([^a-zA-Z0-9_])/sprintf("%%%02X",unpack("c",$1))/ge;
		$key = $rename{$key} if defined $rename{$key};
		next unless $key;
		warn "\"$key\" already defined as \"$INDEX{$key}\", trying to redefine as \"$url#$name\""
			if ($INDEX{$key} && $key ne $lastkey && $INDEX{$key} ne "$url#$name");
		$INDEX{$lastkey = $key} ||= "$url#$name";
	}
	while (($key,$value) = each(%alias)) {
		warn "\"$key\" already defined as \"$INDEX{$key}\", trying to redefine as \"$INDEX{$value}\""
			if ($INDEX{$key} && $key ne $lastkey && $INDEX{$key} ne $INDEX{$value});
		warn "\"$value\" undefined" unless $INDEX{$value};
		$INDEX{$lastkey = $key} ||= $INDEX{$value};
	}
	
	close INDEX;
	unlink $indexfile;
}
