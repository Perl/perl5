#!/usr/bin/perl
'di ';
'ds 00 \"';
'ig 00 ';

use Getopt::Std;

$usage='h2xs [-Aachfm] [-n module_name] [headerfile [extra_libraries]]
	-a	Omit AutoLoad facilities from .pm file.
	-c	Omit the constant() function from the XS file.
	-A	Equivalent to -a -c 
	-f	Force creation of the extension even if the C header does not exist.
	-h 	help
	-n	Specify a name to use for the extension.
extra_libraries are any libraries that might be needed for loading
	the extension, e.g. -lm would try to link in the math library.
';

sub usage{ die "Usage: $usage\n" }

getopts("fhcaAn:") || &usage;

&usage if $opt_h;

if( @ARGV ){
	$path_h = shift;
}
elsif( ! @ARGV && ! $opt_n ){
	die "Must supply header file or module name\n";
}

$extralibs = "@ARGV";
if( $opt_A ){
	$opt_a = $opt_c = 1;
}

if( $path_h ){
	$name = $path_h;
	if( $path_h =~ s#::#/#g && $opt_n ){
		warn "Nesting of headerfile ignored with -n\n";
	}
	$path_h .= ".h" unless $path_h =~ /\.h$/;
	$path_h = "/usr/include/$path_h" unless $path_h =~ m#^[./]#;
	die "Can't find $path_h\n" if( ! $opt_f && ! -f $path_h );
}

$module = $opt_n || do {
	$name =~ s/\.h$//;
	if( $name !~ /::/ ){
		$name =~ s#^.*/##;
		$name = "\u$name";
	}
	$name;
};

chdir 'ext' if -d 'ext';

if( $module =~ /::/ ){
	$nested = 1;
	@modparts = split(/::/,$module);
	$modfname = $modparts[-1];
	$modpname = join('/',@modparts);
}
else {
	$nested = 0;
	@modparts = ();
	$modfname = $modpname = $module;
}


die "Won't overwrite existing ext/$modpname\n" if -e $modpname;
# quick hack, should really loop over @modparts
mkdir($modparts[0], 0777) if $nested;
mkdir($modpname, 0777);
chdir($modpname) || die "Can't chdir ext/$modpname: $!\n";

open(XS, ">$modfname.xs") || die "Can't create ext/$modpname/$modfname.xs: $!\n";
open(PM, ">$modfname.pm") || die "Can't create ext/$modpname/$modfname.pm: $!\n";


if( -r $path_h ){
    open(CH, "<$path_h") || die "Can't open $path_h: $!\n";
    while (<CH>) {
	if (/^#[ \t]*define\s+(\w+)\b\s*[^("]/) {
	    $_ = $1;
	    next if /^_.*_h_*$/i;
	    $names{$_}++;
	    @AZ = 'A' .. 'Z' if !@AZ && /^[A-Z]/;
	    @az = 'a' .. 'z' if !@az && /^[a-z]/;
	    @under = '_' if !@under && /^_/;
	}
    }
    close(CH);
    @names = sort keys %names;
}

$" = "\n\t";
warn "Writing ext/$modpname/$modfname.pm\n";

if( ! $opt_a ){
print PM <<"END";
package $module;

require Exporter;
require AutoLoader;
require DynaLoader;
\@ISA = qw(Exporter AutoLoader DynaLoader);
# Items to export into callers namespace by default
# (move infrequently used names to \@EXPORT_OK below)
\@EXPORT = qw(
	@names
);
# Other items we are prepared to export if requested
\@EXPORT_OK = qw(
);

sub AUTOLOAD {
    if (\@_ > 1) {
	\$AutoLoader::AUTOLOAD = \$AUTOLOAD;
	goto &AutoLoader::AUTOLOAD;
    }
    local(\$constname);
    (\$constname = \$AUTOLOAD) =~ s/.*:://;
    \$val = constant(\$constname, \@_ ? \$_[0] : 0);
    if (\$! != 0) {
	if (\$! =~ /Invalid/) {
	    \$AutoLoader::AUTOLOAD = \$AUTOLOAD;
	    goto &AutoLoader::AUTOLOAD;
	}
	else {
	    (\$pack,\$file,\$line) = caller;
	    die "Your vendor has not defined $module macro \$constname, used at \$file line \$line.\n";
	}
    }
    eval "sub \$AUTOLOAD { \$val }";
    goto &\$AUTOLOAD;
}

bootstrap $module;

# Preloaded methods go here.  Autoload methods go after __END__, and are
# processed by the autosplit program.

1;
__END__
END
}
else{
print PM <<"END";
package $module;

require Exporter;
require DynaLoader;
\@ISA = qw(Exporter DynaLoader);
# Items to export into callers namespace by default
\@EXPORT = qw();
# Other items we are prepared to export if requested
\@EXPORT_OK = qw();


bootstrap $module;

1;
END
}

close PM;

warn "Writing ext/$modpname/$modfname.xs\n";
print XS <<"END";
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

END
if( $path_h ){
	my($h) = $path_h;
	$h =~ s#^/usr/include/##;
print XS <<"END";
#include <$h>

END
}

if( ! $opt_c ){
print XS <<"END";
static int
not_here(s)
char *s;
{
    croak("$module::%s not implemented on this architecture", s);
    return -1;
}

static double
constant(name, arg)
char *name;
int arg;
{
    errno = 0;
    switch (*name) {
END

foreach $letter (@AZ, @az, @under) {

    last if $letter eq 'a' && !@names;

    print XS "    case '$letter':\n";
    my($name);
    while (substr($names[0],0,1) eq $letter) {
	$name = shift(@names);
	print XS <<"END";
	if (strEQ(name, "$name"))
#ifdef $name
	    return $name;
#else
	    goto not_there;
#endif
END
    }
    print XS <<"END";
	break;
END
}
print XS <<"END";
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}


MODULE = $module		PACKAGE = $module

double
constant(name,arg)
	char *		name
	int		arg

END
}
else{
print XS <<"END";

MODULE = $module		PACKAGE = $module

END
}

close XS;

{
warn "Writing ext/$modpname/Makefile.PL\n";
open(PL, ">Makefile.PL") || die "Can't create ext/$modpname/Makefile.PL: $!\n";

print PL <<'END';
use ExtUtils::MakeMaker;
# See lib/ExtUtils/MakeMaker.pm for details of how to influence
# the contents of the Makefile that is written.
END
print PL "WriteMakefile(\n";
print PL "    'NAME'	=> '$module',\n";
print PL "    'VERSION'	=> '0.1',\n";
print PL "    'LIBS'	=> ['$extralibs'],   # e.g., '-lm' \n";
print PL "    'DEFINE'	=> '',     # e.g., '-DHAVE_SOMETHING' \n";
print PL "    'INC'	=> '',     # e.g., '-I/usr/include/other' \n";
print PL ");\n";
}

system '/bin/ls > MANIFEST';


##############################################################################

	# These next few lines are legal in both Perl and nroff.

.00 ;			# finish .ig
 
'di			\" finish diversion--previous line must be blank
.nr nl 0-1		\" fake up transition to first page again
.nr % 0			\" start at page 1
'; __END__ ############# From here on it's a standard manual page ############
.TH H2XS 1 "August 9, 1994"
.AT 3
.SH NAME
h2xs \- convert .h C header files to Perl extensions
.SH SYNOPSIS
.B h2xs [-Aachfm] [-n module_name] [headerfile [extra_libraries]]
.SH DESCRIPTION
.I h2xs
builds a Perl extension from any C header file.  The extension will include
functions which can be used to retrieve the value of any #define statement
which was in the C header.
.PP
The 
.I module_name
will be used for the name of the extension.  If module_name is not supplied
then the name of the header file will be used, with the first character
capitalized.
.PP
If the extension might need extra libraries, they should be included
here.  The extension Makefile.PL will take care of checking whether
the libraries actually exist and how they should be loaded.
The extra libraries should be specified in the form -lm -lposix, etc,
just as on the cc command line.  By default, the Makefile.PL will
search through the library path determined by Configure.  That path
can be augmented by including arguments of the form -L/another/library/path
in the extra-libraries argument.
.SH OPTIONS
.TP
.B \-f
Allows an extension to be created for a header even if that
header is not found in /usr/include.
.TP
.B \-a
Omit AutoLoad(), AUTOLOAD, and autosplit from the .pm and Makefile files.
.TP
.B \-c
Omit constant() from the .xs file.
.TP
.B \-n module_name
Specifies a name to be used for the extension.
.TP
.B \-A
Turns on both -a and -c.
.SH EXAMPLES
.nf

	# Default behavior, extension is Rusers
	h2xs rpcsvc/rusers

	# Same, but extension is RUSERS
	h2xs -n RUSERS rpcsvc/rusers

	# Extension is rpcsvc::rusers. Still finds <rpcsvc/rusers.h>
	h2xs rpcsvc::rusers

	# Extension is ONC::RPC.  Still finds <rpcsvc/rusers.h>
	h2xs -n ONC::RPC rpcsvc/rusers

	# Without AUTOLOAD, AutoLoad, autosplit
	h2xs -a rpcsvc/rusers

	# Creates templates for an extension named RPC
	h2xs -Afn RPC

	# Extension is ONC::RPC.
	h2xs -An ONC::RPC

	# Makefile.PL will look for library -lrpc in 
	# additional directory /opt/net/lib
	h2xs rpcsvc/rusers -L/opt/net/lib -lrpc

.fi
.SH ENVIRONMENT
No environment variables are used.
.SH AUTHOR
Larry Wall
.SH "SEE ALSO"
perl(1) ExtUtils::MakeMaker
.SH DIAGNOSTICS
The usual warnings if it can't read or write the files involved.
.ex
